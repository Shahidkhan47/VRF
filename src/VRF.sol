// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

/// @title The Casino Game
/// @author Shahidkhan
/// @notice Its like a Casino game where owner will create one slot and maximum upto five members can participate with their choice number(1 to 32) in that slot then
/// @notice owner will spin and get one random value between 1 to 32.Whoever matches the number will get reward.(participation fee will be 0.1 ether).

interface ISupraRouterContract {
    function generateRequest(
        string memory _functionSig,
        uint8 _rngCount,
        uint256 _numConfirmations,
        uint256 _clientSeed,
        address _clientWalletAddress
    ) external returns (uint256);

    function generateRequest(
        string memory _functionSig,
        uint8 _rngCount,
        uint256 _numConfirmations,
        address _clientWalletAddress
    ) external returns (uint256);
}

contract Vrf {
    uint256 private constant MIN_ETH_BALANCE = 100000000000000000 wei;
    uint8 public constant MAX_PARTICIPANTS = 5;
    address public owner;
    address supraAddr;
    ISupraRouterContract internal supraRouter;

    enum GameStatus {
        ACTIVE,
        SPINNED,
        FINALIZED
    }

    struct Gamedetails {
        Participant[] participants;
        uint256 winnerNumber;
        uint256 totalAmount;
        uint8 totalusers;
        GameStatus status;
        mapping(address => bool) hasParticipated;
    }
    struct Participant {
        address participant;
        uint256 choice;
        bool winner;
    }
    bytes32[] internal Identifiers;

    constructor(address _supraAddr) {
        supraRouter = ISupraRouterContract(_supraAddr);
        owner = msg.sender;
        supraAddr = _supraAddr;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, "Only owner can call this function");
        _;
    }

    //GameId => Gamedetails(struct)
    mapping(bytes32 => Gamedetails) public gamedetails;

    //Nonce => GameId
    mapping(uint256 => bytes32) public nonceToGameId;

    receive() external payable {}

    fallback() external payable {}

    /// @notice Creating game slot
    /// @param _gameNum gamenumber by an owner
    /// @param _text A text for particular game slot
    function creategame(
        uint256 _gameNum,
        string memory _text
    ) external onlyOwner returns (bytes32 _iden) {
        _iden = keccak256(abi.encodePacked(block.timestamp, _text, _gameNum));
        gamedetails[_iden];
        Identifiers.push(_iden);

        return _iden;
    }

    /// @notice Getting random number by supraAddress and updating it into mapping(this function only called by supra contract directly)
    /// @param _nonce nonce of request to generate random number
    /// @param  _rngList generated random numbers array from vrf
    function getnumber(uint256 _nonce, uint256[] memory _rngList) external {
        bytes32 _gameId = nonceToGameId[_nonce];
        Gamedetails storage gameDetails = gamedetails[_gameId];
        gameDetails.winnerNumber = (_rngList[0] % 32);
    }

    /// @notice To participate in particular game slot
    /// @param _gameId gameId generated by owner while creating a game
    /// @param _choice choice number by participant
    function participate(bytes32 _gameId, uint256 _choice) external payable {
        Gamedetails storage gameDetails = gamedetails[_gameId];
        require(
            gameDetails.status == GameStatus.ACTIVE,
            "Participation time already ended"
        );
        require(
            gameDetails.participants.length < MAX_PARTICIPANTS,
            "Max limit reached"
        );
        require(
            !gameDetails.hasParticipated[msg.sender],
            "already participated"
        );
        require(
            (msg.sender).balance >= MIN_ETH_BALANCE,
            "Insufficient Balance"
        );
        require(
            1 <= _choice && _choice <= 32,
            "You can only choose numbers between 1 and 32"
        );
        require(
            msg.value == 100000000000000000 wei,
            "You have to send exactly 0.1 ether to participate"
        );

        gameDetails.hasParticipated[msg.sender] = true;

        gameDetails.participants.push(
            Participant({
                participant: msg.sender,
                choice: _choice,
                winner: false
            })
        );
        gameDetails.totalAmount = gameDetails.totalAmount + MIN_ETH_BALANCE;
        gameDetails.totalusers++;
    }

    /// @notice Spin function only called by an owner to generate random number
    /// @param _gameId gameId generated by owner while creating a game
    function spin(bytes32 _gameId) external onlyOwner {
        Gamedetails storage gameDetails = gamedetails[_gameId];
        require(
            gameDetails.participants.length >= 3,
            "Not enough participants"
        );
        require(gameDetails.status == GameStatus.ACTIVE, "Game already ended");
        uint8 rngCount = 1;
        uint256 numConfirmations = 1;
        uint256 nonce = supraRouter.generateRequest(
            "getnumber(uint256,uint256[])",
            rngCount,
            numConfirmations,
            msg.sender
        );
        nonceToGameId[nonce] = _gameId;
        gameDetails.status = GameStatus.SPINNED;
    }

    /// @notice Finalize function only called by an owner to distribute rewards after spin
    /// @param _gameId gameId generated by owner while creating a game
    function finalize(bytes32 _gameId) external payable onlyOwner {
        Gamedetails storage gameDetails = gamedetails[_gameId];
        require(
            gameDetails.status == GameStatus.SPINNED,
            "Game has to spin first"
        );
        uint256 winNum = gameDetails.winnerNumber;
        bool winnerFound;
        uint256 winningAmount = gameDetails.totalAmount / 2;
        for (uint256 i = 0; i < gameDetails.participants.length; i++) {
            if (winNum == gameDetails.participants[i].choice) {
                (bool sent, ) = payable(gameDetails.participants[i].participant)
                    .call{value: winningAmount}("");
                require(sent, "transaction Failed");
                gameDetails.participants[i].winner = true;
                winnerFound = true;
                break;
            }
        }
        for (uint256 i = 0; i < gameDetails.participants.length; i++) {
            if (!winnerFound) {
                uint256 amountToGive = winningAmount / gameDetails.totalusers;
                (bool ok, ) = payable(gameDetails.participants[i].participant)
                    .call{value: amountToGive}("");
                require(ok, "Transaction of giving everyone equal failed");
            }
        }
        gameDetails.status = GameStatus.FINALIZED;
    }

    /// @notice To fetch winnerNumber for specific game slot
    /// @param _gameId gameId generated by owner while creating a game
    function getWinnerNumber(bytes32 _gameId) external view returns (uint256) {
        Gamedetails storage gameDetails = gamedetails[_gameId];
        require(
            gameDetails.status != GameStatus.ACTIVE,
            "Wait for random number"
        );
        return gameDetails.winnerNumber;
    }
    /// @notice To fetch GameIds created by an owner
    function fetchIds() external view returns (bytes32[] memory) {
        return Identifiers;
    }
}
